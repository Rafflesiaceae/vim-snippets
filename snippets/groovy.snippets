snippet v "shorthand variable declaration"
	${1} := ${2}
snippet vr "variable initialization"
	var ${1:t} ${0:string}
snippet var "variable declaration"
	var ${1} ${2} = ${3}
snippet vars "variables declaration"
	var (
		${1} ${2} = ${3}
	)
snippet ap "append"
	append(${1:slice}, ${0:value})
snippet bl "bool"
	bool
snippet bt "byte"
	byte
snippet br "break"
	break
snippet ch "channel"
	chan ${0:int}
snippet cs "CompileStatic"
	@CompileStatic
snippet tc "TupleConstructor"
	@TupleConstructor
snippet co "constants with iota"
	const (
		${1:NAME1} = iota
		${0:NAME2}
	)
snippet cn "continue"
	continue
snippet df "defer"
	defer ${0:func}()
snippet dfr "defer recover"
	defer func() {
		if err := recover(); err != nil {
			${0:${VISUAL}}
		}
	}()
# snippet im "import"
# 	import (
# 		"${1:package}"
# 	)
snippet in "interface"
	interface{}
snippet inf "full interface "
	interface ${1:name} {
		${2:/* methods */}
	}
snippet if "if condition"
	if (${1:/* condition */}) {
		${2:${VISUAL}}
	}
snippet ife "if else condition"
	if (${1:/* condition */}) {
		${2:${VISUAL}}
	} else {
		${0}
	}
snippet imt "import transform"
	import groovy.transform.*
snippet el "else"
	else {
		${0:${VISUAL}}
	}
snippet f "false"
	false
snippet fl "float"
	float32
snippet f3 "float32"
	float32
snippet f6 "float64"
	float64
snippet field "field"
	@Field static final ${1:FOO} = ${2:[ " ", "\t", "\n" ]}
snippet fieldp "field private"
	@Field static private final ${1:FOO} = ${2:[ " ", "\t", "\n" ]}
snippet while "while loop"
	while (${1:true}) {
		${0:${VISUAL}}
	}
# @XXX not supported with the groovy in the latest Jenkins version
# snippet for "for int loop"
# 	for (${1:i} = 0, ${2:len} = ${3:FOO.length()}; $1 < $2; $1${4:++}) {
# 		${0:${VISUAL}}
# 	}
snippet for "for c loop"
	for (${1:i} = 0; $1 < ${2:foo.length()}; $1${4:++}) {
		${0:${VISUAL}}
	}
snippet fori "for in loop"
	for (${1:item} in ${2:list}) {
		${0:${VISUAL}}
	}
snippet int "interface"
	interface ${1:FooBar} {
		${0:${VISUAL}}
		int foo()
		void bar()
	}
snippet throw "throw an exception"
	throw new ${2:Exception}(${1:${VISUAL}})
snippet try "try catch finally"
	try {
		${1}
	} catch ( ${2:IOException | NullPointerException e} ) {
		${3}
	} finally {
		${4}
	}
snippet fun "function"
	func ${1:funcName}(${2}) ${3:error} {
		${4}
	}
	${0}
snippet fum "method"
	func (${1:receiver} ${2:type}) ${3:funcName}(${4}) ${5:error} {
		${6}
	}
	${0}
snippet fumh "http handler function on receiver"
	func (${1:receiver} ${2:type}) ${3:funcName}(${4:w} http.ResponseWriter, ${5:r} *http.Request) {
		${0:${VISUAL}}
	}
snippet l "list"
	List<${1:String}>
snippet lf "log printf"
	log.Printf("%${1:s}", ${2:var})
snippet lp "log println"
	log.Println("${1}")
snippet mk "make"
	make(${1:[]string}, ${0:0})
snippet mp "map"
	map[${1:string}]${0:int}
snippet main "func main()"
	static void main(String... args) {
		${0:${VISUAL}}
	}
snippet nw "new"
	new(${0:type})
snippet pa "package"
	package ${1:main}
snippet pn "panic"
	panic("${0:msg}")
snippet pf "fmt.Printf()"
	fmt.Printf("%${1:s}\n", ${2:var})
snippet pl "fmt.Println()"
	fmt.Println("${1:s}")
snippet pr "println"
	println(${1:foo})
snippet rn "range"
	range ${0}
snippet rt "return"
	return ${0}
snippet rs "result"
	result
snippet sd "static def"
	static def ${1:foo}(${2:String contents}) {
		${0:${VISUAL}}
	}
snippet spd "static private def"
	static private def ${1:foo}(${2:String contents}) {
		${0:${VISUAL}}
	}
snippet sr "string"
	string
snippet st "struct"
	struct ${1:name} {
		${2:/* data */}
	}
	${0}
snippet switch "switch"
	switch (${1:var}) {
	case ${2:value1}:
		break;
	case [ ${3:1, 2} ]:
		break;
	default:
		${0:${VISUAL}}
		break;
	}
snippet ps "fmt.Sprintf"
	fmt.Sprintf("%${1:s}", ${2:var})
snippet t "true"
	true
snippet g "goroutine named function"
	go ${1:funcName}(${0})
snippet ga "goroutine anonymous function"
	go func(${1} ${2:type}) {
		${3:/* code */}
	}(${0})
snippet test "test function"
	func Test${1:name}(t *testing.T) {
		${0:${VISUAL}}
	}
snippet testt "table test function"
	func Test${1:name}(t *testing.T) {
		tests := []struct {
			name string
		}{
			{
				name: "${2:test name}",
			},
		}

		for _, test := range tests {
			t.Run(test.name, func(t *testing.T) {
				${0:${VISUAL}}
			})
		}
	}
snippet bench "benchmark function"
	func Benchmark${1:name}(b *testing.B) {
		for i := 0; i < b.N; i++ {
			${2}
		}
	}
	${0}
snippet cl "class"
	class ${1:Name} {
		${2:${VISUAL}}
	}
snippet jcl "jenkins class"
	@TupleConstructor
	class ${1:Name} implements Serializable {
		${2:${VISUAL}}
	}
snippet om "if key in a map"
	if ${1:value}, ok := ${2:map}[${3:key}]; ok == true {
		${4:/* code */}
	}
snippet gg "Grouped globals with anonymous struct"
	var ${1:var} = struct{
		${2:name} ${3:type}
	}{
		$2: ${4:value},
	}
snippet ja "Marshalable json alias"
	type ${1:parentType}Alias $1

	func (p *$1) MarshalJSON() ([]byte, error) {
		return json.Marshal(&struct{ *$1Alias }{(*$1Alias)(p)})
	}
snippet errwr "Error handling with errors.Wrap"
	if ${1}err != nil {
		return errors.Wrap(err, "${2}")
	}
